<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html class=" yeeaweh idc0_350"><head><title>Rotations</title>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta content="Microsoft FrontPage 4.0" name="GENERATOR">
<meta content="FrontPage.Editor.Document" name="ProgId"></head>
<body>
<p align="center"><font color="#000080" face="Courier" size="5"><b>Rotations, the how's 
and why's...</b></font></p>
<p><font face="Courier"><font color="#000080" face="Courier" size="4"><b><br></b></font><br><font color="#800000"><b>I. 
Introduction</b></font><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I bet 
you felt very annoyed by the fact that I only explained projection on my first 
article right? Well, the series is primarily geared to coders who had no 
experience in 3d coding and to advance one's knowledge regarding 3d in 
general.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This time around, I will 
be explaining to you 2d and 3d rotations. "2D rotation in a 3d article?!!! Are 
you out of your mind?!!!" Hardly, in fact, 2d rotation is the basis of 3d 
rotation as you will know later. But before I could discuss rotations to you, 
let me start by some basic intermediate and trigonometric math. Don't worry, 
this is not as hard as you might think. So prepare yourself for some street 
math. ;*)<br><br></font></p>
<p><font face="Courier"><font color="#800000"><b>II. The polar coordinate 
system<br></b></font><br>Up to this point, we have used the cartesian coordinate 
system in 2d or in 3d. Coordinates in these systems are defined as either p(x,y) 
or p(x,y,z).&nbsp;<br>In the polar coordinate system however, the ordered pair 
is not represented by x or y but of r and angle originating from the origin or 
the pole, which is the center of the coordinate system. Given an angle Theta and 
a radius r the ordered pair would be written as: 
p(r,theta).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#000080">r</font> represents the distance from pole,<br>and <font color="#000080">theta </font>is the measure of the angle from the positive 
x-axis.<br></font></p>
<p align="center"><img border="0" height="346" src="chapter2_files/polar.gif" width="512"></p>
<p><font face="Courier"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; So in the 
polar system, we only need the length(r), sometimes called the magnitude, and 
the angle from the positive x-axis. Why discuss polar system when the monitor is 
best suited for a cartesian system? The answer is that some things can be easily 
done in the polar coordinate system. And one of those things is "rotation" 
;*)<br><br></font></p>
<p><font color="#800000" face="Courier"><b>III. The basic trigonometric functions 
and</b></font><font face="Courier"> <font color="#800000"><b>their relationship to 
the Polar and Cartesian 
systems...<br></b></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; There 
are six basic trig functions. The <font color="#000080">sine, cosine, tangent, 
secant, cosecant,</font> and the <font color="#000080">cotangent</font>. As of the 
moment, we are interested in just 2, the <b>SINE</b> and 
<b>COSINE</b>.</font></p>
<p align="center"><font face="Courier"><br><img border="0" height="346" src="chapter2_files/Unitcircle.gif" width="512"></font></p>
<p><font face="Courier"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Say you 
have the unit circle above(a unit circle is a circle having a radius of 1), with 
an angle(theta) at 45 degrees. I already drew the right triangle for you labeled 
as Y or O(Opposite side), X or A(adjacent side) and r or H(Hypoteneuse. In 
Trigonometry, there is a mnemonic called the "SOH-CAH-TOA" which roughly 
means:<br><br><font color="#000080">&nbsp;&nbsp;&nbsp;</font> <font color="#000080">SOH = Sin(Theta) = Opposite/Hypoteneuse<br>&nbsp;&nbsp;&nbsp; CAH 
= Cos(Theta) = Adjacent/Hypoteneuse<br>&nbsp;&nbsp;&nbsp; TOA = Tan(Theta) = 
Take a wild guess. :p<br></font><br>Translating it to x,y and r..</font></p>
<p><font face="Courier"><br><font color="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
sin(theta)=y/r<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
cos(theta)=x/r</font></font></p>
<p><font face="Courier"><font color="#000080"><br></font>As I said we only need SIN 
and COS for now.<br><br>Multiplying both sides by r...</font></p>
<p><font face="Courier"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#000080">r(Sin(Theta) = y/r)r<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
r(Cos(Theta) = x/r)r</font><br>&nbsp;&nbsp;&nbsp; 
=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080"> 
r*(Sin(Theta) = y<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r*(Cos(Theta) = 
x<br>&nbsp;&nbsp;&nbsp; =</font><br>&nbsp;&nbsp;&nbsp; EQ. 
1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#000080">x = r * 
cos(Theta)</font><br>&nbsp;&nbsp;&nbsp; EQ. 
1-1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#000080">y = r * 
sin(Theta)</font><br><br>Since on a unit circle r = 1 
then<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#000080">x = 1 
* cos(Theta)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 1 * 
sin(Theta)</font><br>&nbsp;&nbsp;&nbsp; or&nbsp;<br>&nbsp;&nbsp;&nbsp; EQ. 
2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#000080">x = 
cos(Theta)</font><br>&nbsp;&nbsp;&nbsp; EQ. 
2-1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#000080">y = 
sin(Theta)<br></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; By now you 
should already have realized that Sine has something to do with the y coordinate 
and Cosine to the x coord. ;*)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Now 
how do we convert from polar to cartesian? Easy, as long as you know the radius 
and the angle(theta) just pluck the values to EQ's 1 and 1-1.<br>ie:</font></p>
<p><font face="Courier"><br><font color="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = r * 
cos(Theta)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = r * 
sin(Theta)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Pset(x,y)</font></font></p>
<p><font face="Courier"><br>Here's and example file:<br><a href="http://rel.phatcode.net/mytutes/3dtutes/chapter2/Files/POLROT.BAS">PolRot.Bas</a> 
</font></p>
<p><font face="Courier"><br>To change form polar to cartesian:<br><br><font color="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
r&nbsp;&nbsp;&nbsp;&nbsp; = Sqr(x^2 + 
y^2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Theta = ATN(y/x); 
x&lt;&gt;0&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</font><i>*These 2 would be useful later on but keep it on the sidelines for 
now. ;*)<br></i>Before forget, all the other trig functions can be derived from 
the SIN and COS function.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#000080">Tan(a) = 
Sin(a)/Cos(a)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sec(a) = 
1/Cos(a)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Csc(a) = 
1/Sin(a)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cot(a) = 1/Tan(a) = 
Cos(a)/Sin(a)<br></font><br></font></p>
<p><font face="Courier"><b><font color="#800000">IV. Degrees and 
Radians<br></font></b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Okay, this 
is very important so listen closely. We, as students are used with the degree 
measurement of angles. Probably because degrees are easy to visualize, so our 
teachers and beginners math books use it. But it turns out that computer 
languages, BASIC included, cannot directly accept degree measure in their built 
in trig functions. Why? Frankly, I don't know. Maybe because radians is an exact 
measure or the implementors just want to be cooler. 
:*)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Now, since QB won't let you 
pass degrees to their built-in trig functions, and radians is sometimes a pain 
to implement(due to the fact that it's a small value), we have to use degree 
measurement and converting it to radian measure before passing it to the 
functions.<br>To convert:</font></p>
<p><font face="Courier"><br><b>&nbsp;&nbsp;&nbsp;</b> <b>1. Degrees to 
Radians<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b><font color="#000080">Radians = Degrees*PI/180</font><br><b>&nbsp;&nbsp;&nbsp;</b> <b>2. 
Radians to Degrees<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b><font color="#000080">Degrees = 
Radians*180/PI<br></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>*PI 
is a value of the circumference of a circle divided by its diameter. Its actual 
value is 3.141593...<br></i><b>Fun fact:</b> Pi is 180 degrees. Guess what 2*PI 
is? :*)<br><b>Fun fact:</b> You can easily calculate PI by 
PI=ATN(1)*4<br><br><br><font color="#800000"><b>V. 2d 
Rotation<br></b></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Using the 
polar system to rotate a point around the center is pretty easy. But how about 
rotation from the point's coordinate itself? This is where our 2d coordinate 
rotation comes from. Rotating from p(x,y) to p(x',y'):<br><br></font></p>
<p align="center"><img border="0" height="346" src="chapter2_files/Rotangle.gif" width="512"></p>
<p><font face="Courier"><br><br><font color="#000080">&nbsp;&nbsp;&nbsp; x' = 
x*cos(Theta) - y*sin(Theta)<br>&nbsp;&nbsp;&nbsp; y' = y*cos(Theta) + 
x*sin(Theta)<br></font>Where:<br>&nbsp;&nbsp;&nbsp; <font color="#000080">x&nbsp; 
= original x coord<br>&nbsp;&nbsp;&nbsp; y&nbsp; = original y 
coord<br>&nbsp;&nbsp;&nbsp; x' = rotated x coord<br>&nbsp;&nbsp;&nbsp; y' = 
rotated y coord</font><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; But how 
did those equations came about? Most articles just smack you into these 
equations and never look back on how those came to be. I bet some of them 
doesn't know how to derive it themselves. :*). And because I'm different, I will 
teach you how they came to be. Moreso, you could impress your friends by your 
geekiness when you tell them you know. :*)<br><br><font color="#800000"><b>V-a. 
Proof on how the 2d rotation is derived.<br></b></font><br>Remember these 
equations?<br>&nbsp;&nbsp;&nbsp; EQ. 
1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080"> x = r * 
cos(Theta)<br></font>&nbsp;&nbsp;&nbsp; EQ. 1-1<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">&nbsp;&nbsp;&nbsp; y = r * 
sin(Theta)<br></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yep they are the 
Polar to Cartesian coordinate system conversion. :*)<br>We also need the 
<b><i>Angle addition identities </i></b></font></p>
<p align="center"><font face="Courier"><b><i><br><img border="0" height="346" src="chapter2_files/addangle.gif" width="512"> </i></b></font></p>
<p><font face="Courier"><br>Legend:<br><font color="#000080"><b>P</b> = 
Phi<br><b>T</b> = Theta<br></font><br><i><b>Cosine Identity:</b></i><br>EQ. 
3<br>&nbsp;&nbsp;&nbsp; <font color="#000080">Cos(P+T)= 
Cos(P)*Cos(T)-Sin(P)*Sin(T)</font><br><b><i>Sine Identity:</i></b><br>EQ. 
3-1<br>&nbsp;&nbsp;&nbsp; <font color="#000080">Sin(P+T)= 
Sin(P)*Cos(T)+Cos(P)*Sin(T)</font><br><br>Let (P+T) = Theta(Just one 
angle)...<br>EQ. 1 becomes:<br>&nbsp;&nbsp;&nbsp; <font color="#000080">x = r * 
cos(P+T)<br></font>EQ. 1-1<br>&nbsp;&nbsp;&nbsp; <font color="#000080">y = r * 
sin(P+T)</font><br><br>Then by substitution from EQ 1 and 1-1<br>EQ. 1 
becomes:<br>&nbsp;&nbsp;&nbsp; <font color="#000080">x' = r * 
(Cos(P)*Cos(T)-Sin(P)*Sin(T))<br></font>EQ. 1-1 becomes:<br>&nbsp;&nbsp;&nbsp; 
<font color="#000080">y' = r * 
(Sin(P)*Cos(T)+Cos(P)*Sin(T))<br></font><br>Distributing 
r:<br><br>&nbsp;&nbsp;&nbsp; <font color="#000080">x' = r*Cos(P)*Cos(T) - 
r*Sin(P)*Sin(T)<br>&nbsp;&nbsp;&nbsp; y' = r*Sin(P)*Cos(T) + 
r*Cos(P)*Sin(T)<br></font><br>And looking back at EQ's 1 and 1-1:<br>Let P = 
Theta...<br>&nbsp;&nbsp;&nbsp; <font color="#000080">x = r * 
cos(P)<br>&nbsp;&nbsp;&nbsp; y = r * sin(P)<br></font><br>Then by 
substitution:</font></p>
<p><font face="Courier"><br>&nbsp;&nbsp;&nbsp; <font color="#000080">x' = x * Cos(T) 
- y * Sin(T)<br>&nbsp;&nbsp;&nbsp; y' = y * Cos(T) + x * 
Sin(T)</font><br><br>And Viola!!! That's how you prove the 2d rotation formula. 
;*)<br><br><b>Final equations:</b></font></p>
<p><font face="Courier"><br><font color="#000080"><b>&nbsp;&nbsp;&nbsp; 
Newx=oldx*Cos(Theta) - oldy*Sin(Theta)<br>&nbsp;&nbsp;&nbsp; 
Newy=oldy*Cos(Theta) + 
oldx*Sin(Theta)<br></b></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
*Note: Actually, had I used EQ's 2 and 2-1, the proof would be much easier since 
r is already removed. Though I believe that using r forces you to understand the 
concept behind the proof. So as an exercise, why don't you try it yourself? 
;*)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If you have understood all 
the stuff that I have written form article 1 up to here, you might have already 
guessed that our standard 2d rotation is THE SAME AS ROTATING FROM THE Z-AXIS. 
If you did, good. If not, look again on this figure:</font></p>
<p><font face="Courier"><br></font></p>
<p align="center"><img border="0" height="136" src="chapter2_files/Rightsys.gif" width="161"></p>
<p><font face="Courier"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; See, 
rotating from the z-axis rotates your point on the XY plane. Here's the code 
supplement which added rotations to our previous starfield. Don't get dizzy. 
:*)<br><a href="http://rel.phatcode.net/mytutes/3dtutes/chapter2/Files/PROJ-ROT.BAS">Proj-rot.Bas<br></a><br><br><b><font color="#800000">VI. Let's go 
3d!!!!<br></font></b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Remember 
when I said that 3d rotation is almost like 2d rotation? Well, I'm not a man who 
breaks my word. So let me begin by saying that since rotation on the z-axis 
takes on the xy plane and rotation on the x-axis takes on the yz plane, where do 
you think rotation on the y axis take place? Yes, the xz plane!. 
:*)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Now doing these rotations are 
pretty straightforward, all we have to do is smack the needed values on our 2d 
rotation equation for each axis and we're good to go. One thing to remember 
though is <i>"TO USE THE OLD VALUES UNTIL THE NEW ONES ARE FOUND"</i>. Which 
means for a full rotation on all the axes, do not directly put values until they 
are fully rotated on the axis that they are rotated.<br><br>Here's the full 3d 
rotation Equations:<br>*All values are floating point 
numbers<br><br>'***Rotation on the Z-axis<br><font color="#000080">NewY = 
y*cos(Thetax) - z*sin(Thetax)<br>NewZ = z*cos(Thetax) + y*sin(Thetax)<br>y = 
NewY<br>z = NewZ<br></font><br>'***Rotation on the Y-axis<br><font color="#000080">NewZ = z*cos(Thetay) - x*sin(Thetay)<br>NewX = x*cos(Thetay) + 
z*sin(Thetay)<br>x = NewX<br></font><br>'***Rotation on the Z-axis<br><font color="#000080">NewX = x*cos(Thetaz) - y*sin(Thetaz)<br>NewY = y*cos(Thetaz) + 
x*sin(Thetaz)<br></font><br><font color="#000080">Rotatedx = NewX<br>Rotatedy = 
NewY<br>Rotatedz = NewZ<br></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Your rotated x/y/z are the points completely rotated over the x,y and z axes. I 
had to save the rotated values at some point to make it work or our rotations 
wouldn't look right. :*). Its also notable that <i>"THE ORDER IN WHICH YOU 
ROTATE FROM EACH AXIS IS VERY IMPORTANT"</i>. Rotating in z-x-y order would not 
produce the same result as rotating in the x-y-z order. I'm using x-y-z because 
of the alphabet. Actually, Kiwidog's rotation is in x-y-z order and since his 
article started me with 3d, I'm writing this as a tribute to him. As they say, 
"old habits die hard".:*)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Since, QB's implementation of the FPU(The Floating Point Unit) is really crap, 
we could optimize this by using lookup tables or just calculating some constants 
before the actual rotation equations.<br>ie.</font></p>
<p><font face="Courier"><br><b><font color="#000080" size="3"><i>QBcode:<br></i></font><font color="#000080" face="Courier" size="2">&nbsp;&nbsp;&nbsp; cx! = COS(AngleX!)<br>&nbsp;&nbsp;&nbsp; sx! = 
SIN(AngleX!)<br>&nbsp;&nbsp;&nbsp; cy! = COS(AngleY!)<br>&nbsp;&nbsp;&nbsp; sy! 
= SIN(AngleY!)<br>&nbsp;&nbsp;&nbsp; cz! = COS(AngleZ!)<br>&nbsp;&nbsp;&nbsp; 
sz! = SIN(AngleZ!)<br><br>&nbsp;&nbsp;&nbsp; FOR i = 0 TO 
Maxpoints<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x! = 
model(i).x<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y! = 
model(i).y<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z! = 
model(i).z<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewY! = (y! * cx!) 
- (z! * sx!)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewZ! = (z! * cx!) + 
(y! * sx!)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y! = 
NewY!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z! = 
NewZ!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewZ! = (z! * cy!) - (x! * 
sy!)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewX! = (x! * cy!) + 
(z! * sy!)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x! = 
NewX!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewX! = (x! * cz!) - (y! * 
sz!)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewY! = (y! * cz!) + 
(x! * sz!)<br>&nbsp;&nbsp;&nbsp; Next i&nbsp;<br></font></b></font></p>
<p><font face="Courier"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Doing this 
would speed your render a lot. :*)&nbsp;<br>Here's an example file:<br><a href="http://rel.phatcode.net/mytutes/3dtutes/chapter2/Files/3DROT.BAS">3drot.bas<br></a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Before I forget, to translate, subtract cam(x,y,z) AFTER rotation. Unless, you'd 
want your rotations to be off-center. Think about when to use either. Heck, why 
don't you try it to see the effects? 
:*)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; However, there's still a 
faster way to rotate. Notice the amount of multiplication just to to do a full 3 
axis rotation? Yep, 12 multiplies! It turns out that we can reduce this to just 
9! But how do we do it? Either by using matrices or weeding out constants using 
standard algebra. Both methods would work well and would roughly produce the 
same result. Same nine multiplies, same amount of arithmetic. Though you could 
directly translate the points using the 4th row of a 4*4 matrix, we can also do 
it by subtracting our camera value from the rotated coordinate. And if you look 
closely either the matrix or the algebra method would produce the same 
constants. :*) *I will touch up on matrices after the texturemapping article so 
don't worry. :*)<br></font></p>
<p><font face="Courier"><br><b><font color="#800000">VII. From 12 to 
9<br></font></b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; There are other 
articles discussing this type of optimization but sadly, the final 3*3 matrix 
just does not rotate right. So if you want to derive a final 3*3 matrix yourself 
from your own rotation order, you have to do it yourself. 
:*)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BTW, the constants we will 
derive after this is a 3*3 rotation matrix. We just didn't use the matrix way 
but the algebra 101 way. :*)<br><br>So now let's begin the 
headache.<br><br><b>Standard 12 mul rotation:<br></b><br>Let <font color="#000080">ox,oy,oz</font> the old coords<br><br>Let <font color="#000080">nx,ny,nz</font> the new rotated coords<br><br><font color="#000080">&nbsp;&nbsp;&nbsp; cx = cos(anglex)<br>&nbsp;&nbsp;&nbsp; cy = 
cos(angley)<br>&nbsp;&nbsp;&nbsp; cz = cos(anglez)<br><br>&nbsp;&nbsp;&nbsp; sx 
= sin(anglex)<br>&nbsp;&nbsp;&nbsp; sy = sin(angley)<br>&nbsp;&nbsp;&nbsp; sz = 
sin(anglez)<br></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I'm 
numbering the equations for easy referencing later so you won't get lost in the 
mess.&nbsp;<br><br>******<br><font color="#000000">1.</font><font color="#000080"> 
ny = oy*cx - oz*sx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'x axis<br></font><font color="#000000">2.</font><font color="#000080"> nz = oz*cx + oy*sx<br><br>oy = 
ny<br>oz = nz<br><br></font><font color="#000000">3.</font><font color="#000080"> nz 
= oz*cy - ox*sy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'y axis<br></font><font color="#000000">4. </font><font color="#000080">nx = ox*cy + oz*sy<br><br>oy = 
ny<br>oz = nz<br><br></font><font color="#000000">5.</font><font color="#000080"> nx 
= ox*cz - oy*sz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'z axis<br></font><font color="#000000">6.</font><font color="#000080"> ny = oy*cz + 
ox*sz<br><br></font>'''All points rotated ;*)<br><br>*****<br><br><i>*From 12 to 
9 multiplies. We will simplify each axis equation starting from the x axis. Not 
the numbers as they reference equations from our original 12 mul 
rotation.<br></i><br>So...<br><font color="#000080">&nbsp;&nbsp;&nbsp; Oz(2) = 
Nz(2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = Nz = oz*cx + 
oy*sx<br></font><br><i>* I don't know if this would make sense to you but this 
I'm trying to minimize the text for the actual math to be understandable. 
;*)<br></i><br>****For X axis....<br><br><font color="#000080">nx(4) = 
ox*cy+oz*sy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'orig<br>nx(4) = 
ox*cy+oz(2)*sy<br></font><br>*let's substitute nz(2) to oz<br><font color="#000080">nx(4) = ox*cy+[oz*cx+oy*sx]*sy<br></font><br>*distribute sy inside 
nz(2)<br><font color="#000080">nx(4) = ox*cy+oz*cx*sy+oy*sx*sy<br>nx(5) = 
ox*cz-oy*sz 'orig<br></font><br>*now substitute nx(4) and ny(1)<br><font color="#000080">nx(5) = 
[ox*cy+oz*cx*sy+oy*sx*sy]*cz<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
-[oy*cx-oz*sx]*sz<br></font><br>*distribute cz and sz<br><font color="#000080">nx(5) = 
ox*cy*cz+oz*cx*sy*cz+oy*sx*sy*cz<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
-[oy*cx*sz-oz*sx*sz]<br></font><br>*distribute the negative sign(-) and remove 
parenthesis.<br><b>(note the change of signs)<br></b><font color="#000080">nx(5)= 
ox*cy*cz+oz*cx*sy*cz+oy*sx*sy*cz<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
-oy*cx*sz+oz*sx*sz<br></font><br>*use the commutative property of addition to 
reorder the terms in x+y+z order.<br><font color="#000080">nx(5) 
=&nbsp;&nbsp;&nbsp; 
ox*cy*cz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
'X<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + oy*sx*sy*cz - oy*cx*sz 
'y<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + oz*cx*sy*cz + oz*sx*sz 
'Z<br></font><br>*factor out x,y and z<br><font color="#000080">nx(5) 
=&nbsp;&nbsp; 
ox*[cy*cz]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
'X<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + oy*[sx*sy*cz - cx*sz] 
'y<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + oz*[cx*sy*cz + sx*sz] 
'Z<br></font><br>*We already have precalculated the constants to use(inside 
square brackets). Let's store 'em.<br><br>so...<br><font color="#000080"><b>&nbsp;&nbsp;&nbsp;</b></font> <font color="#000080"><b>xx = 
cy*cz<br>&nbsp;&nbsp;&nbsp; xy = sx*sy*cz - cx*sz<br>&nbsp;&nbsp;&nbsp; xz = 
cx*sy*cz + sx*sz<br></b></font><br>****For Y axis...<br><br><font color="#000080">ny(6) = oy(1)*cz + ox(4)*sz<br>ny(6) = [oy*cx - 
oz*sx]*cz<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
+{ox*cy+[oz*cx+oy*sx]*sy}*sz<br></font><br>*distribute cz and sy<br><font color="#000080">ny(6) = oy*cx*cz - 
oz*sx*cz<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
+[ox*cy+oz*cx*sy+oy*sx*sy]*sz<br>ny(6) = oy*cx*cz - 
oz*sx*sy*cz&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +ox*cy*sz + 
oz*cx*sy*sz + oy*sx*sy*sz<br></font><br>*Rearrange in x,y,z order<br><font color="#000080">ny(6) = ox*cy*sz<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
+oy*cx*cz + oy*sx*sy*sz<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -oz*sx*cz 
+ oz*cx*sy*sz</font><br><br>*Factor out x,y and z<br><font color="#000080">ny(6) = 
ox*cy*sz<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +oy*cx*cz + 
oy*sx*sy*sz<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -oz*sx*cz + 
oz*cx*sy*sz<br>ny(6) = ox*[cy*sz]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
+oy*[cx*cz + sx*sy*sz]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -oz*[sx*cz 
+ cx*sy*sz]<br></font><br>*oz has a (-) sign. Make sx*cz negative so that we 
could use addition.<br><font color="#000080">ny(6) = 
ox*[cy*sz]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +oy*[cx*cz + 
sx*sy*sz]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +oz*[-sx*cz + 
cx*sy*sz]</font><br>'store...<br><b><font color="#000080">&nbsp;&nbsp;&nbsp;</font> <font color="#000080">yx = 
cy*sz<br>&nbsp;&nbsp;&nbsp; yy = cx*cz + sx*sy*sz<br>&nbsp;&nbsp;&nbsp; yz = 
-sx*cz + cx*sy*sz<br></font></b><br><br>****For Z axis...(easiest!!!!)<br><font color="#000080">nz(3) = oz(2)*cy - ox*sy</font><br>*substitute nz(2)<br><font color="#000080">nz(3) = [oz*cx + oy*sx]*cy - ox*s</font>y<br>*distribute<br><font color="#000080">nz(3) = oz*cx*cy + oy*sx*cy - ox*sy<br>nz(3) = - ox*sy + oy*sx*cy 
+ oz*cx*cy</font><br><br>*make sy negative as to make ox positive<br><font color="#000080">nz(3) = ox*[-sy] + oy*[sx*cy] + oz*[cx*cy]<br><b>&nbsp;&nbsp; zx = 
-sy<br>&nbsp;&nbsp; zy = sx*cy<br>&nbsp;&nbsp; zz = 
cx*cy</b></font><b><br></b><br>****Final Precalculated constants!!!!<br>****This 
is our final 3*3 Matrix.<br><br>'X axis<br><font color="#000080"><b>xx = 
cy*cz<br>xy = sx*sy*cz - cx*sz<br>xz = cx*sy*cz + sx*sz</b></font><br><br>'Y 
axis<br><font color="#000080"><b>yx = cy*sz<br>yy = cx*cz + sx*sy*sz<br>yz = 
-sx*cz + cx*sy*sz</b></font><br><br>'Z axis<br><font color="#000080"><b>zx = 
-sy<br>zy = sx*cy<br>zz = 
cx*cy</b></font><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; We smack the 
above constants down our<br>original coord and we get the rotated<br>coord 
without much hassle. Faster and<br>simpler too!!!<br><br>Final Equations!!!!(9 
muls only) </font></p>
<p><font face="Courier"><br><font color="#000080"><b>nx = ox*xx + oy*xy + 
oz*xz<br>ny = ox*yx + oy*yy + oz*yz<br>nz = ox*zx + oy*zy + oz*zz</b></font> 
</font></p>
<p><font face="Courier"><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Speed 
increase may not be apparent if<br>you're just rotating a cube but try<br>to 
rotate a 1000 polygon model and<br>you'll see how much speed difference<br>there 
is. ;*)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Here's a sample file 
benchmarking this against the standard 12 mul rotation.<br><br><a href="http://rel.phatcode.net/mytutes/3dtutes/chapter2/Files/3DBENCH.BAS">3dBench.bas<br></a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
You might want to see what's in store for you on the next article. So here is 
just one(Two actually) little part of it. :*)<br><br><a href="http://rel.phatcode.net/mytutes/3dtutes/chapter2/Files/3DWIRE.BAS">3dwire.bas</a> 
</font></p>
<p><font face="Courier"><a href="http://rel.phatcode.net/mytutes/3dtutes/chapter2/Files/TEXTURE.BAS">Texture.Bas<br></a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Lastly, don't limit yourself to just points, you can use sprites for better and 
cooler effects. :*)<br><br><a href="http://rel.phatcode.net/mytutes/3dtutes/chapter2/Files/VECBALLS.BAS">vecballs.bas<br></a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Get yourself a stretchsprite routine and you cam make some even cooler 
stuff!!!<br><br><a href="http://rel.phatcode.net/mytutes/3dtutes/chapter2/Files/STRETCH.BAS">stretch.bas<br></a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
From now on I'll be using the 3*3 matrix constants as opposed to the 12 mul 
rotation so that our renders are a lot faster. And also because it will not only 
be points that we will rotate later but VECTORS. :*)&nbsp; There is also a 
better way to rotate than this.&nbsp; I'll take it up when we get to matrices. 
:*)&nbsp;<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Now go ahead and 
code yourself a 3d rotator even if its just a cube. Because next time I'll be 
discussing to you on how to generate 3d shapes the math way and I'll touch up on 
polygons so that you can fill your models at runtime and impress your friends. 
I'll also touch up on 2 more 3d coordinate systems. The SPHERICAL and 
CYLINDRICAL coordinate systems. :*). So until next 'ish, Happy 
Coding!!!<br><br>Credits:<br><br>Kiwidog for introducing me to the world of 
3d<br>Plasma357 for SetVideoSeg<br>SCM for proofreading<br>Biskbart for the 
tesselation algo <br><br><br>Relsoft 2003<br><a href="mailto:vic_viperph@yahoo.com">vic_viperph@yahoo.com<br></a><a href="http://rel.phatcode.net/">rel.phatcode.net</a><br><br></font></p>
</body></html>